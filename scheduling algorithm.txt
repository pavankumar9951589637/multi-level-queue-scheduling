#include <stdio.h>
#include <stdlib.h>

struct Process {
    int id;
    int priority;
    int burst_time;
};

struct Queue {
    struct Process* processes;
    int front, rear;
    int size;
};

int processCount = 0;

struct Process createProcess(int id, int priority, int burst_time) {
    struct Process p;
    p.id = id;
    p.priority = priority;
    p.burst_time = burst_time;
    return p;
}

struct Queue createQueue(int size) {
    struct Queue q;
    q.size = size;
    q.processes = (struct Process*)malloc(size * sizeof(struct Process));
    q.rear = q.front = -1;
    return q;
}

int isQueueEmpty(struct Queue* q) {
    return (q->front == -1 && q->rear == -1);
}

int isQueueFull(struct Queue* q) {
    return ((q->rear + 1) % q->size == q->front);
}

void enqueue(struct Queue* q, struct Process process) {
    if (isQueueFull(q)) {
        printf("Queue is full. Can't enqueue\n");
        return;
    }
    if (isQueueEmpty(q)) {
        q->front = q->rear = 0;
        q->processes[q->rear] = process;
    } else {
        q->rear = (q->rear + 1) % q->size;
        q->processes[q->rear] = process;
    }
}

struct Process dequeue(struct Queue* q) {
    struct Process emptyProcess;
    emptyProcess.id = -1;

    if (isQueueEmpty(q)) {
        printf("Queue is Empty\n");
        return emptyProcess;
    }
    struct Process process = q->processes[q->front];
    if (q->front == q->rear) {
        q->front = q->rear = -1;
    } else
        q->front = (q->front + 1) % q->size;

    return process;
}

void executePriorityQueue(struct Queue* q1, struct Queue* q2) {
    struct Process processesArray[q1->size];
    struct Process toStore;

    while (!isQueueEmpty(q1)) {
        processesArray[processCount] = dequeue(q1);
        processCount++;
    }
    for (int i = 0; i < processCount - 1; i++) {
        for (int j = i + 1; j < processCount; j++) {
            if (processesArray[j].priority < processesArray[i].priority) {
                struct Process temp = processesArray[i];
                processesArray[i] = processesArray[j];
                processesArray[j] = temp;
            }
        }
    }
    for (int i = 0; i < processCount; i++) {
        toStore = processesArray[i];
    }
    for (int i = 0; i < processCount; i++) {
        struct Process process = processesArray[i];
        printf("Currently running process %d from Queue 1 (Priority: %d)\n", process.id, process.priority);

        process.burst_time -= 2;
        if (process.burst_time == 0) {
            printf("Process %d Executed Completely\n", process.id);
        }

        if (process.burst_time > 0) {
            printf("Process %d Moved to Queue 2\n", process.id);
            enqueue(q2, process);
        }
    }
}

void executeRoundRobinQueue(struct Queue* q2) {
    struct Process toStore1;
    while (!isQueueEmpty(q2)) {
        toStore1 = dequeue(q2);
        struct Process process = toStore1;
        printf("Currently running process %d from Queue 2 (Round Robin)\n", process.id);
        process.burst_time -= 2;
        if (process.burst_time > 0) {
            enqueue(q2, process);
        }
    }
}

int main() {
    struct Queue q1 = createQueue(50);
    struct Queue q2 = createQueue(50);

    int numProcesses;
    printf("Enter the number of processes: ");
    scanf("%d", &numProcesses);

    for (int i = 0; i < numProcesses; i++) {
        int id, priority, burst_time;
        printf("Enter details for Process %d (id, priority, burst time): ", i + 1);
        scanf("%d %d %d", &id, &priority, &burst_time);
        struct Process p = createProcess(id, priority, burst_time);
        enqueue(&q1, p);
    }

    executePriorityQueue(&q1, &q2);
    executeRoundRobinQueue(&q2);

    return 0;
}

